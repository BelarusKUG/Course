<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.9">
<title>Программа курса "Kotlin School"</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Программа курса "Kotlin School"</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_описание_курса">Описание курса</a></li>
<li><a href="#_требования_к_слушателям">Требования к слушателям</a></li>
<li><a href="#_цели">Цели</a></li>
<li><a href="#_ожидаемые_результаты_по_окончанию_курса">Ожидаемые результаты по окончанию курса</a></li>
<li><a href="#_лекции">Лекции</a>
<ul class="sectlevel2">
<li><a href="#_формат_проведения_лекций">Формат проведения лекций</a></li>
<li><a href="#_1_вводная">1. Вводная</a></li>
<li><a href="#_2_ооп">2. ООП</a></li>
<li><a href="#_классы_и_наследование">Классы и наследование</a></li>
<li><a href="#_классы_данных">Классы данных</a></li>
<li><a href="#_делегированные_свойства">Делегированные свойства</a></li>
<li><a href="#_делегирование">Делегирование</a></li>
<li><a href="#_перечисляемые_типы">Перечисляемые типы</a></li>
<li><a href="#_интерфейсы">Интерфейсы</a></li>
<li><a href="#_вложенные_классы">Вложенные классы</a></li>
<li><a href="#_анонимные_объекты_и_объявление_объектов">Анонимные объекты и объявление объектов</a></li>
<li><a href="#_свойства_и_поля">Свойства и поля</a></li>
<li><a href="#_изолированные_классы">Изолированные классы</a></li>
<li><a href="#_ключевое_слово_this">Ключевое слово this</a></li>
<li><a href="#_модификаторы_доступа">Модификаторы доступа</a></li>
<li><a href="#_3_стандартная_библиотека">3. Стандартная библиотека</a></li>
<li><a href="#_4_функциональное_программирование">4. Функциональное программирование</a></li>
<li><a href="#_5_generic">5. Generic</a></li>
<li><a href="#_6_kotlin_dsl_multiplatform">6. Kotlin DSL + Multiplatform</a></li>
<li><a href="#_7_корутины">7. Корутины</a></li>
<li><a href="#_8_обратная_совместимость_с_java">8. Обратная совместимость с Java</a></li>
</ul>
</li>
<li><a href="#_puzzler">Puzzler</a>
<ul class="sectlevel2">
<li><a href="#_9_экосистема_kotlin">9. Экосистема Kotlin</a></li>
</ul>
</li>
<li><a href="#_команда_курса">Команда курса</a>
<ul class="sectlevel2">
<li><a href="#_лекторы">Лекторы</a></li>
<li><a href="#_менторы">Менторы</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_описание_курса">Описание курса</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Базовый курс рассчитан на знакомство с основными возможностями языка Kotlin, знакомство с функциональным программированием, переход/совмещение с Java в проекте, обсуждение популярных библиотек и инфраструктуру для разработке на языке.</p>
</div>
<div class="paragraph">
<p>Главной целью курса является научить разработчиков использовать идиоматические подходы Kotlin и использовать его подходы, вместо того чтобы писать Kotlin код в Java стиле.</p>
</div>
<div class="paragraph">
<p>В рамках курсах будет рассказываться о Kotlin 1.3.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_требования_к_слушателям">Требования к слушателям</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Разработчики, имеющие опыт создания приложения на Java: бекенд, десктопные или Android, или имеющие опыт использования Kotlin, но только его базового функционала.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_цели">Цели</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Повысить культуры использования языка Kotlin</p>
</li>
<li>
<p>Создание новых разработчиков, способных писать на Kotlin</p>
</li>
<li>
<p>Популяризация Kotlin</p>
</li>
<li>
<p>Привлечение новых людей в сообщество BKUG</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ожидаемые_результаты_по_окончанию_курса">Ожидаемые результаты по окончанию курса</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В конце курса ожидается, что слушатели, прошедшие его смогут:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Использовать Kotlin в проекте</p>
</li>
<li>
<p>Совмещать Kotlin код c Java</p>
</li>
<li>
<p>Переводить Java код в Kotlin</p>
</li>
<li>
<p>Эффективно использовать функционал из стандартной библиотеки Kotlin</p>
</li>
<li>
<p>Применять функциональные подходы программирования Kotlin в проектах</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_лекции">Лекции</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_формат_проведения_лекций">Формат проведения лекций</h3>
<div class="paragraph">
<p>Лекция длится около 1-1.5 часа. В рамках нее происходит обсуждение темы и должно выдаваться домашнее задание.</p>
</div>
<div class="paragraph">
<p><strong>Порядок тем в лекциях произвольный</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_1_вводная">1. Вводная</h3>
<div class="ulist">
<ul>
<li>
<p>Знакомство с командой</p>
</li>
<li>
<p>История языка</p>
</li>
<li>
<p>Tooling для разработки</p>
</li>
<li>
<p>Kotlin Education Plugin</p>
</li>
<li>
<p>Kotlin/JVM, Kotlin/JS, Kotlin/Native</p>
</li>
<li>
<p>Возможности совмещения языков (JVM + Kotlin, JS + Kotlin &amp; etc)</p>
</li>
<li>
<p>Поддерживаемые идиомы программирования</p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/reference/coding-conventions.html">Kotlin Coding Conventions</a></p>
</li>
<li>
<p>Базовый синтаксис</p>
<div class="ulist">
<ul>
<li>
<p>Базовые типы</p>
</li>
<li>
<p>Объявление переменных</p>
</li>
<li>
<p>Null safety</p>
</li>
<li>
<p>Type Inference (Выведение типов)</p>
</li>
<li>
<p>Массивы и коллекции</p>
</li>
<li>
<p>Объявление функций</p>
</li>
<li>
<p>Extension функции</p>
</li>
<li>
<p>If, when, циклы</p>
</li>
<li>
<p>Обработка исключений</p>
</li>
</ul>
</div>
</li>
<li>
<p>Литература</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_ооп">2. ООП</h3>
<div class="ulist">
<ul>
<li>
<p>Объявление классов</p>
</li>
<li>
<p>Конструкторы</p>
</li>
<li>
<p>Модификаторы видимости</p>
<div class="ulist">
<ul>
<li>
<p>Primary</p>
</li>
<li>
<p>Secondary</p>
</li>
</ul>
</div>
</li>
<li>
<p>Properties</p>
</li>
<li>
<p>Наследование</p>
</li>
<li>
<p>Интерфейсы</p>
</li>
<li>
<p>Data классы</p>
</li>
<li>
<p>Sealed классы</p>
</li>
<li>
<p>Object</p>
</li>
<li>
<p>Делегирование: классы и property</p>
</li>
<li>
<p>Enums</p>
</li>
<li>
<p>Companion object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Мы предполагаем что слушатель курса уже знает основы ООП, и в лекции будут рассказаны особенности ООП в Kotlin.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Важные отличия: В Kotlin в отличии от Java нету статических методов и переменных, для объявления статических данных использоваются companion object.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_классы_и_наследование">Классы и наследование</h3>
<div class="sect3">
<h4 id="_классы">Классы</h4>
<div class="paragraph">
<p>Классы в &lt;b&gt;Kotlin&lt;/b&gt; объявляются с помощью использования ключевого слова <strong>class</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Invoice {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объявление класса состоит из имени класса, заголовка (указания типов его параметров, первичного конструктора и т.п) и тела класса,
заключённого в фигурные скобки. И заголовок, и тело класса являются необязательными составляющими: если у класса нет тела, фигурные скобки могут быть опущены.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Empty</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;a name="constructors"&gt;&lt;/a&gt;</p>
</div>
<div class="sect5">
<h6 id="_конструкторы">Конструкторы</h6>
<div class="paragraph">
<p>Класс в &lt;b&gt;Kotlin&lt;/b&gt; может иметь первичный конструктор (<strong>primary constructor</strong>) и один или более вторичных конструкторов (<strong>secondary constructors</strong>). Первичный конструктор является частью заголовка класса, его объявление идёт сразу после имени класса (и необязательных параметров):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Person constructor(firstName: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у конструктора нет аннотаций и модификаторов видимости, ключевое слово <strong>constructor</strong> может быть опущено:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Person(firstName: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первичный конструктор не может содержать в себе исполняемого кода. Инициализирующий код может быть помещён в соответствующий блок (<strong>initializers blocks</strong>), который помечается словом <strong>init</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Customer(name: String) {
    init {
        logger.info("Customer initialized with value ${name}")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что параметры первичного конструктора могут быть использованы в инициализирующем блоке. Они также могут быть использованы при инициализации свойств в теле класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Customer(name: String) {
    val customerKey = name.toUpperCase()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В действительности, для объявления и инициализации свойств первичного конструктора в &lt;b&gt;Kotlin&lt;/b&gt; есть лаконичное синтаксическое решение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Person(val firstName: String, val lastName: String, var age: Int) {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Свойства, объявленные в первичном конструкторе, могут быть изменяемые (<strong>var</strong>) и неизменяемые (<strong>val</strong>).</p>
</div>
<div class="paragraph">
<p>Если у конструктора есть аннотации или модификаторы видимости, ключевое слово <strong>constructor</strong> обязательно, и модификаторы используются перед ним:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Customer public @Inject constructor(name: String) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для более подробной информации по данному вопросу см. <a href="visibility-modifiers.html#constructors">"Модификаторы доступа"</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_второстепенные_конструкторы">Второстепенные конструкторы</h6>
<div class="paragraph">
<p>В классах также могут быть объявлены дополнительные конструкторы (<strong>secondary constructors</strong>), перед которыми используется ключевое слово <strong>constructor</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Person {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у класса есть главный (первичный) конструктор, каждый последующий конструктор должен прямо или косвенно ссылаться (через другой(<em>ие</em>) конструктор(<em>ы</em>)) на первичный:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Person(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если в абстрактном классе не объявлено никаких конструкторов (первичных или второстепенных), у этого класса автоматически сгенерируется пустой конструктор без параметров. Видимость этого конструктора будет <strong>public</strong>. Если вы не желаете иметь класс с открытым <strong>public</strong> конструктором, вам необходимо объявить пустой конструктор с соответствующим модификатором видимости:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class DontCreateMe private constructor () {
}</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Примечание</strong>: В виртуальной машине JVM компилятор генерирует дополнительный конструктор без параметров в случае, если все параметры первичного конструктора имеют значения по умолчанию. Это делает использование таких библиотек, как &lt;b&gt;Jackson&lt;/b&gt; и &lt;b&gt;JPA&lt;/b&gt;, более простым в языке &lt;b&gt;Kotlin&lt;/b&gt;, так как они используют пустые конструкторы при создании экземпляров классов.</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Customer(val customerName: String = "")</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_создание_экземпляров_классов">Создание экземпляров классов</h6>
<div class="paragraph">
<p>Для создания экземпляра класса конструктор вызывается так, как если бы он был обычной функцией:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val invoice = Invoice()

val customer = Customer("Joe Smith")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обращаем ваше внимание на то, что в &lt;b&gt;Kotlin&lt;/b&gt; не используется ключевое слово <strong>new</strong>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_члены_класса">Члены класса</h6>
<div class="paragraph">
<p>Классы могут содержать в себе:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Конструкторы и инициализирующие блоки</p>
</li>
<li>
<p><a href="functions.html">Функции</a></p>
</li>
<li>
<p><a href="properties.html">Свойства</a></p>
</li>
<li>
<p><a href="nested-classes.html">Вложенные классы</a></p>
</li>
<li>
<p><a href="object-declarations.html">Объявления объектов</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;a name="inheritance"&gt;&lt;/a&gt;</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_наследование">Наследование</h4>
<div class="paragraph">
<p>Для всех классов в языке &lt;b&gt;Koltin&lt;/b&gt; родительским суперклассом является класс <code>Any</code>. Он также является родительским классом для любого класса, в котором не указан какой-либо другой родительский класс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Example // Implicitly inherits from Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класс <code>Any</code> не является аналогом <code>java.lang.Object</code>. В частности, у него нет никаких членов кроме методов: <code>equals()</code>, <code>hashCode()</code>, и <code>toString()</code>. Пожалуйста, ознакомьтесь с <a href="http://kotlinlang.org/docs/reference/java-interop.html#object-methods">совместимостью c Java</a> для более подробной информации.</p>
</div>
<div class="paragraph">
<p>Для явного объявления суперкласса мы помещаем его имя за знаком двоеточия в оглавлении класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class Base(p: Int)

class Derived(p: Int) : Base(p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у класса есть основной конструктор, базовый тип может (и должен) быть проинициализирован там же, с использованием параметров первичного конструктора.</p>
</div>
<div class="paragraph">
<p>Если у класса нет первичного конструктора, тогда каждый последующий второстепенный конструктор должен включать в себя инициализацию базового типа с помощью ключевого слова <strong>super</strong> или давать отсылку на другой конструктор, который это делает.
Примечательно, что любые вторичные конструкторы могут ссылаться на разные конструкторы базового типа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class MyView : View {
    constructor(ctx: Context) : super(ctx) {
    }

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ключевое слово <strong>open</strong> является противоположностью слову <strong>final</strong> в &lt;b&gt;Java&lt;/b&gt;: оно позволяет другим классам наследоваться от данного. По умолчанию, все классы в &lt;b&gt;Kotlin&lt;/b&gt; имеют статус <strong>final</strong>, что отвечает <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>, Item 17: <em>Design and document for inheritance or else prohibit it</em>.</p>
</div>
<div class="paragraph">
<p>&lt;a name="overriding-properties"&gt;&lt;/a&gt;</p>
</div>
<div class="sect5">
<h6 id="_переопределение_членов_класса">Переопределение членов класса</h6>
<div class="paragraph">
<p>Как упоминалось ранее, мы придерживаемся идеи определённости и ясности в языке &lt;b&gt;Kotlin&lt;/b&gt;. И, в отличие от &lt;b&gt;Java&lt;/b&gt;, &lt;b&gt;Kotlin&lt;/b&gt;
требует чёткой аннотации и для членов, которые могут быть переопределены, и для самого переопределения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class Base {
  open fun v() {}
  fun nv() {}
}
class Derived() : Base() {
  override fun v() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для <code>Derived.v()</code> необходима аннотация <strong>override</strong>. В случае её отсутствия компилятор выдаст ошибку. Если у функции типа <code>Base.nv()</code> нет аннотации <strong>open</strong>, объявление метода с такой же сигнатурой в производном классе невозможно, с <strong>override</strong> или без. В <strong>final</strong> классе (классе без аннотации <strong>open</strong>), запрещено использование аннотации <strong>open</strong> для его членов.</p>
</div>
<div class="paragraph">
<p>Член класса, помеченный <strong>override</strong>, является сам по себе <strong>open</strong>, т.е. он может быть переопределён в производных классах. Если вы хотите запретить возможность переопределения такого члена, используйте <strong>final</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class AnotherDerived() : Base() {
  final override fun v() {}
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_стойте_как_мне_теперь_хакнуть_свои_библиотеки">Стойте! Как мне теперь хакнуть свои библиотеки?</h6>
<div class="paragraph">
<p>При нашем подходе к переопределению классов и их членов (которые по дефолту <strong>final</strong>) будет сложно унаследоваться от чего-нибудь внутри используемых вами библиотек для того, чтобы переопределить не предназначенный для этого метод и внедрить туда свой гнусный хак.</p>
</div>
<div class="paragraph">
<p>Мы думаем, что это не является недостатком по следующим причинам:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Опыт поколений говорит о том, что, в любом случае, лучше не позволять внедрять такие хаки</p>
</li>
<li>
<p>Люди успешно используют другие языки (&lt;b&gt;C++&lt;/b&gt;, &lt;b&gt;C#&lt;/b&gt;), которые имеют аналогичный подход к этому вопросу</p>
</li>
<li>
<p>Если кто-то действительно хочет хакнуть, пусть напишет свой код на &lt;b&gt;Java&lt;/b&gt; и вызовет его в &lt;b&gt;Kotlin&lt;/b&gt; <em>(см. <a href="http://kotlinlang.org/docs/reference/java-interop.html">Java-совместимость</a>)</em></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_правила_переопределения">Правила переопределения</h6>
<div class="paragraph">
<p>В &lt;b&gt;Kotlin&lt;/b&gt; правила наследования имплементации определены следующим образом: если класс перенимает большое количество имплементаций одного и того члена от ближайших родительских классов, он должен переопределить этот член и обеспечить свою собственную имплементацию (возможно, используя одну из унаследованных). Для того, чтобы отметить супертип (родительский класс), от которого мы унаследовали данную имплементацию, мы используем ключевое слово <strong>super</strong>. Для уточнения имя родительского супертипа используются треугольные скобки, например <code>super&lt;Base&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class A {
  open fun f() { print("A") }
  fun a() { print("a") }
}

interface B {
  fun f() { print("B") } // interface members are 'open' by default
  fun b() { print("b") }
}

class C() : A(), B {
  // The compiler requires f() to be overridden:
  override fun f() {
    super&lt;A&gt;.f() // call to A.f()
    super&lt;B&gt;.f() // call to B.f()
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Нормально наследоваться одновременно от <code>A</code> и <code>B</code>. У нас не возникнет никаких проблем с <code>a()</code> и <code>b()</code> в том случае, если <code>C</code> унаследует только одну имплементацию этих функций.
Но для <code>f()</code> у нас есть две имплементации, унаследованные классом <code>C</code>, поэтому необходимо переопределить <code>f()</code> в <code>C</code> и обеспечить нашу собственную реализацию этого метода для устранения получившейся неоднозначности.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_абстрактные_классы">Абстрактные классы</h4>
<div class="paragraph">
<p>Класс и некоторые его члены могут быть объявлены как <strong>abstract</strong>. Абстрактный член не имеет реализации в его классе.
Обратите внимание, что нам не надо аннотировать абстрактный класс или функцию словом <strong>open</strong> - это подразумевается и так.</p>
</div>
<div class="paragraph">
<p>Можно переопределить не-абстрактный <strong>open</strong> член абстрактным</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class Base {
  open fun f() {}
}

abstract class Derived : Base() {
  override abstract fun f()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_объекты_помощники">Объекты-помощники</h4>
<div class="paragraph">
<p>В &lt;b&gt;Kotlin&lt;/b&gt;, в отличие от &lt;b&gt;Java&lt;/b&gt; или &lt;b&gt;C#&lt;/b&gt;, в классах не бывает статических методов. В большинстве случаев рекомендуется использовать функции на уровне пакета (ориг.: <em>"package-level functions"</em>).</p>
</div>
<div class="paragraph">
<p>Если вам нужно написать функцию, которая может быть использована без создания экземпляра класса, но имела бы доступ к данным внутри этого класса (к примеру, фабричный метод), вы можете написать её как член <a href="object-declarations.html">объявления объекта</a> внутри этого класса.</p>
</div>
<div class="paragraph">
<p>В частности, если вы объявляете <a href="object-declarations.html#companion-objects">объект-помощник</a> в своём классе, у вас появляется возможность обращаться к его членам, используя тот же синтаксис, как при использовании статических методов в &lt;b&gt;Java&lt;/b&gt;/&lt;b&gt;C#&lt;/b&gt; (указав название класса для доступа).</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_классы_данных">Классы данных</h3>
<div class="paragraph">
<p>Нередко мы создаём классы, единственным назначением которых является хранение данных. Функционал таких классов зависит от самих данных, которые в них хранятся. В &lt;b&gt;Kotlin&lt;/b&gt; класс может быть отмечен словом <code>data</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">data class User(val name: String, val age: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой класс называется <em>классом данных</em>. Компилятор автоматически извлекает все члены данного класса из свойств, объявленных в первичном конструкторе:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>пара функций <code>equals()</code>/<code>hashCode()</code>,</p>
</li>
<li>
<p><code>toString()</code> в форме <code>&quot;User(name=John, age=42)&quot;</code>,</p>
</li>
<li>
<p>функции <a href="multi-declarations.html">componentN()</a>, которые соответствуют свойствам, в зависимости от их порядка либо объявления,</p>
</li>
<li>
<p>функция <code>copy()</code> (см. ниже)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если какая-либо из этих функций явно определена в теле класса (или унаследована от родительского класса), то генерироваться она не будет.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы поведение генерируемого кода соответствовало здравому смыслу, классы данных должны быть оформлены с соблюдением некоторых требований:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Первичный конструктор должен иметь как минимум один параметр;</p>
</li>
<li>
<p>Все параметры первичного конструктора должны быть отмечены, как <code>val</code> или <code>var</code>;</p>
</li>
<li>
<p>Классы данных не могут быть абстрактными, open, sealed или inner;</p>
</li>
<li>
<p>Дата-классы не могут наследоваться от других классов (но могут реализовывать интерфейсы).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Начиная с версии 1.1, классы данных могут расширять другие классы (см. примеры в <a href="sealed-classes.html#sealed-classes-and-data-classes">Sealed classes</a>)</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Для того, чтобы у сгенерированного в JVM класса был конструктор без параметров, значения всех свойств должны быть заданы по умолчанию
(см. <a href="classes.html#constructors">Конструкторы</a>)
`kotlin
 data class User(val name: String = &quot;&quot;, val age: Int = 0)
`</p>
</div>
</blockquote>
</div>
<div class="sect3">
<h4 id="_копирование">Копирование</h4>
<div class="paragraph">
<p>Довольно часто нам приходится копировать объект с изменением только <em>некоторых</em> его свойств. Для этой задачи генерируется функция <code>copy()</code>. Для написанного выше класса <code>User</code> такая реализация будет выглядеть следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это позволяет нам писать</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val jack = User(name = "Jack", age = 1)
val olderJack = jack.copy(age = 2)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_классы_данных_и_мульти_декларации">Классы данных и мульти-декларации</h4>
<div class="paragraph">
<p>Сгенерированные для классов данных <em>составные функции</em> позволяют использовать их в <a href="multi-declarations.html">мульти-декларациях</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val jane = User("Jane", 35)
val (name, age) = jane
println("$name, $age years of age") // выводит "Jane, 35 years of age"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_стандартные_классы_данных">Стандартные классы данных</h4>
<div class="paragraph">
<p>Стандартная библиотека предоставляет <code>Pair</code> и <code>Triple</code>. Однако, в большинстве случаев, проименованные классы данных являются лучшим решением, потому что делают код более читаемым, избегая малосодержательные имена для свойств.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://habrahabr.ru/company/JetBrains/blog/152126/">Статья на эту тему на Хабре</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>——————————————————————————–
&lt;!--# Delegated Properties-&#8594;
&lt;!--https://habrahabr.ru/company/JetBrains/blog/183444/-&#8594;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_делегированные_свойства">Делегированные свойства</h3>
<div class="paragraph">
<p><em>За помощь в переводе спасибо <a href="https://habrahabr.ru/company/JetBrains/blog/183444/">официальному блогу JetBrains на Хабрахабре</a></em></p>
</div>
<div class="paragraph">
<p>Существует несколько основных видов свойств, которые мы реализовываем каждый раз вручную в случае их надобности. Однако намного удобнее было бы реализовать их раз и навсегда и положить в какую-нибудь библиотеку. Примеры таких свойств:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ленивые свойства (lazy properties): значение вычисляется один раз, при первом обращении</p>
</li>
<li>
<p>свойства, на события об изменении которых можно подписаться (observable properties)</p>
</li>
<li>
<p>свойства, хранимые в ассоциативном списке, а не в отдельных полях</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для таких случаев, Kotlin поддерживает <em>делегированные свойства</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Example {
    var p: String by Delegate()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Их синтаксис выглядит следующим образом: <code>val/var &lt;имя свойства&gt;: &lt;Тип&gt; by &lt;выражение&gt;</code>. Выражение после <em>by</em> — <em>делегат</em>: обращения (<code>get()</code>, <code>set()</code>) к свойству будут обрабатываться этим выражением.
Делегат не обязан реализовывать какой-то интерфейс, достаточно, чтобы у него были методы <code>getValue()</code> и <code>setValue()</code> с определённой сигнатурой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String {
        return "$thisRef, спасибо за делегирование мне '${property.name}'!"
    }

    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) {
        println("$value было присвоено значению '${property.name} в $thisRef.'")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когда мы читаем значение свойства <code>p</code>, вызывается метод <code>getValue()</code> класса <code>Delegate</code>, причем первым параметром ей передается тот объект, у которого запрашивается свойство <code>p</code>, а вторым — объект-описание самого свойства p (у него можно, в частности, узнать имя свойства). Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val e = Example()
println(e.p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот код выведет</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Example@33a17727, спасибо за делегирование мне ‘p’!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Похожим образом, когда мы обращаемся к <code>p</code>, вызывается метод <code>setValue()</code>. Два первых параметра — такие же, как у get(), а третий — присваиваемое значение свойства:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">e.p = "NEW"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот код выведет</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">NEW было присвоено значению ‘p’ в Example@33a17727.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Спецификация требований к делегированным свойствам может быть найдена <a href="delegated-properties.html#property-delegate-requirements">ниже</a>.</p>
</div>
<div class="paragraph">
<p>Заметьте, что начиная с версии Kotlin 1.1, вы можете объявлять делегированные свойства внутри функций или блоков кода, а не только внутри классов. Снизу вы можете найти пример.</p>
</div>
<div class="sect3">
<h4 id="_стандартные_делегаты">Стандартные делегаты</h4>
<div class="paragraph">
<p>Стандартная библиотека Kotlin предоставляет несколько полезных видов делегатов:</p>
</div>
<div class="sect5">
<h6 id="_ленивые_свойства_lazy_properties">Ленивые свойства (lazy properties)</h6>
<div class="paragraph">
<p><code>lazy()</code> это функция, которая принимает лямбду и возвращает экземпляр класса <code>Lazy&lt;T&gt;</code>, который служит делегатом для реализации ленивого свойства: первый вызов <code>get()</code> запускает лямбда-выражение, переданное <code>lazy()</code> в качестве аргумента, и запоминает полученное значение, а последующие вызовы просто возвращают вычисленное значение.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main(args: Array&lt;String&gt;) {
    println(lazyValue)
    println(lazyValue)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот код выведет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>computed!
Hello
Hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>По умолчанию вычисление ленивых свойств <strong>синхронизировано</strong>: значение вычисляется только в одном потоке выполнения, и все остальные потоки могут видеть одно и то же значение. Если синхронизация не требуется, передайте <code>LazyThreadSafetyMode.PUBLICATION</code> в качестве параметра в функцию <code>lazy()</code>, тогда несколько потоков смогут исполнять вычисление одновременно. Или если вы уверены, что инициализация всегда будет происходить в одном потоке исполнения, вы можете использовать режим <code>LazyThreadSafetyMode.NONE</code>, который не гарантирует никакой потокобезопасности.</p>
</div>
</div>
<div class="sect5">
<h6 id="_observable_свойства">Observable свойства</h6>
<div class="paragraph">
<p>Функция <code>Delegates.observable()</code> принимает два аргумента: начальное значение свойства и обработчик (лямбда), который вызывается при изменении свойства. У обработчика три параметра: описание свойства, которое изменяется, старое значение и новое значение.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable("&lt;no name&gt;") {
        prop, old, new -&gt;
        println("$old -&gt; $new")
    }
}

fun main(args: Array&lt;String&gt;) {
    val user = User()
    user.name = "first"
    user.name = "second"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот код выведет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;no name&gt; -&gt; first
first -&gt; second</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если Вам нужно иметь возможность запретить присваивание некоторых значений, используйте функцию <code>vetoable()</code> вместо <code>observable()</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_хранение_свойств_в_ассоциативном_списке">Хранение свойств в ассоциативном списке</h4>
<div class="paragraph">
<p>Один из самых частых сценариев использования делегированных свойств заключается в хранении свойств в ассоциативном списке. Это полезно в "динамическом" коде, например, при работе с JSON:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class User(val map: Map&lt;String, Any?&gt;) {
    val name: String by map
    val age: Int     by map
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом примере конструктор принимает ассоциативный список</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val user = User(mapOf(
    "name" to "John Doe",
    "age"  to 25
))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Делегированные свойства берут значения из этого ассоциативного списка (по строковым ключам)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">println(user.name) // Prints "John Doe"
println(user.age)  // Prints 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также, если вы используете <code>MutableMap</code> вместо <code>Map</code>, поддерживаются изменяемые свойства (var):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class MutableUser(val map: MutableMap&lt;String, Any?&gt;) {
    var name: String by map
    var age: Int     by map
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_локальные_делегированные_свойства_с_версии_1_1">Локальные делегированные свойства (с версии 1.1)</h4>
<div class="paragraph">
<p>Вы можете объявить локальные переменные как делегированные свойства. Например, вы можете сделать локальную переменную ленивой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun example(computeFoo: () -&gt; Foo) {
    val memoizedFoo by lazy(computeFoo)

    if (someCondition &amp;&amp; memoizedFoo.isValid()) {
        memoizedFoo.doSomething()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>memoizedFoo</code> будет вычислена только при первом обращении к ней.
Если условие <code>someCondition</code> будет ложно, значение переменной не будет вычислено вовсе.</p>
</div>
<div class="paragraph">
<p>&lt;a name="property-delegate-requirements"&gt;&lt;/a&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_требования_к_делегированным_свойствам">Требования к делегированным свойствам</h4>
<div class="paragraph">
<p>Здесь приведены требования к объектам-делегатам.</p>
</div>
<div class="paragraph">
<p>Для <strong>read-only</strong> свойства (например <em>val</em>), делегат должен предоставлять функцию <code>getValue</code>, которая принимает следующие параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisRef</code> — должен иметь такой же тип или быть наследником типа <em>хозяина свойства</em> (для <a href="extensions.html">расширений</a> — тип, который расширяется)</p>
</li>
<li>
<p><code>property</code> — должен быть типа <code>KProperty&lt;*&gt;</code> или его родительского типа. Эта функция должна возвращать значение того же типа, что и свойство (или его родительского типа).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для <strong>изменяемого</strong> свойства (<strong>var</strong>) делегат должен <em>дополнительно</em> предоставлять функцию <code>setValue</code>, которая принимает следующие параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisRef</code> — то же что и у <code>getValue()</code>,</p>
</li>
<li>
<p><code>property</code> — то же что и у <code>getValue()</code>,</p>
</li>
<li>
<p>new value — должен быть того же типа, что и свойство (или его родительского типа).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Функции <code>getValue()</code> и/или <code>setValue()</code> могут быть предоставлены либо как члены класса-делегата, либо как его <a href="extensions.html">расширения</a>. Последнее полезно когда вам нужно делегировать свойство объекту, который изначально не имеет этих функций. Обе эти функции должны быть отмечены с помощью ключевого слова <code>operator</code>.</p>
</div>
<div class="paragraph">
<p>Эти интерфейсы объявлены в стандартной библиотеке Kotlin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface ReadOnlyProperty&lt;in R, out T&gt; {
    operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T
}

interface ReadWriteProperty&lt;in R, T&gt; {
    operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T
    operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_translation_rules">Translation Rules</h6>
<div class="paragraph">
<p>Для каждого делегированного свойства компилятор Kotlin "за кулисами" генерирует вспомогательное свойство и делегирует его. Например, для свойства <code>prop</code> генерируется скрытое свойство <code>prop$delegate</code>, и исполнение геттеров и сеттеров просто делегируется этому дополнительному свойству:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class C {
    var prop: Type by MyDelegate()
}

// этот код генерируется компилятором:
class C {
    private val prop$delegate = MyDelegate()
    var prop: Type
        get() = prop$delegate.getValue(this, this::prop)
        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Компилятор Kotlin предоставляет всю необходимую информацию о <code>prop</code> в аргументах: первый аргумент <code>this</code> ссылается на экземпляр внешнего класса <code>C</code> и <code>this::prop</code> reflection-объект типа <code>KProperty</code>, описывающий сам <code>prop</code>.</p>
</div>
<div class="paragraph">
<p>Заметьте, что синтаксис <code>this::prop</code> для обращения к <a href="http://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11">bound callable reference</a> напрямую в коде программы доступен только с Kotlin версии 1.1</p>
</div>
</div>
<div class="sect5">
<h6 id="_предоставление_делегата">Предоставление делегата</h6>
<div class="paragraph">
<p><em>Примечание: Предоставление делегата доступно в Kotlin начиная с версии 1.1</em></p>
</div>
<div class="paragraph">
<p>С помощью определения оператора <code>provideDelegate</code> вы можете расширить логику создания объекта, которому будет делегировано свойство. Если объект, который используется справа от <code>by</code>, определяет <code>provideDelegate</code> как член или как <a href="extensions.html">расширение</a>, эта функция будет вызвана для создания экземпляра делегата.</p>
</div>
<div class="paragraph">
<p>Один из возможных юзкейсов <code>provideDelegate</code> — это проверка состояния свойства при его создании.</p>
</div>
<div class="paragraph">
<p>Например, если вы хотите проверить имя свойства перед связыванием, вы можете написать что-то вроде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) {
    operator fun provideDelegate(
            thisRef: MyUI,
            prop: KProperty&lt;*&gt;
    ): ReadOnlyProperty&lt;MyUI, T&gt; {
        checkProperty(thisRef, prop.name)
        // создание делегата
    }

    private fun checkProperty(thisRef: MyUI, name: String) { ... }
}

fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; { ... }

class MyUI {
    val image by bindResource(ResourceID.image_id)
    val text by bindResource(ResourceID.text_id)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>provideDelegate</code> имеет те же параметры, что и <code>getValue</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisRef</code> — должен иметь такой же тип, или быть наследником типа <em>хозяина свойства</em> (для <a href="extensions.html">расширений</a> — тип, который расширяется)</p>
</li>
<li>
<p><code>property</code> — должен быть типа <code>KProperty&lt;*&gt;</code> или его родительского типа. Эта функция должна возвращать значение того же типа, что и свойство (или его родительского типа)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Метод <code>provideDelegate</code> вызывается для каждого свойства во время создания экземпляра <code>MyUI</code>, и сразу совершает необходимые проверки.</p>
</div>
<div class="paragraph">
<p>Не будь этой возможности внедрения между свойством и делегатом, для достижения той же функциональности вам бы пришлось передавать имя свойства явно, что не очень удобно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Проверяем имя свойства без "provideDelegate"
class MyUI {
    val image by bindResource(ResourceID.image_id, "image")
    val text by bindResource(ResourceID.text_id, "text")
}

fun &lt;T&gt; MyUI.bindResource(
        id: ResourceID&lt;T&gt;,
        propertyName: String
): ReadOnlyProperty&lt;MyUI, T&gt; {
   checkProperty(this, propertyName)
   // создание делегата
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В сгенерированном коде метод <code>provideDelegate</code> вызывается для инициализации вспомогательного свойства <code>prop$delegate</code>.
Сравните сгенерированный для объявления свойства код <code>val prop: Type by MyDelegate()</code> со сгенерированным кодом из Transaction Rules (когда <code>provideDelegate</code> не представлен):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class C {
    var prop: Type by MyDelegate()
}

// этот код будет сгенерирован компилятором
// когда функция 'provideDelegate' доступна:
class C {
    // вызываем "provideDelegate" для создания вспомогательного свойства "delegate"
    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)
    val prop: Type
        get() = prop$delegate.getValue(this, this::prop)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Заметьте, что метод <code>provideDelegate</code> влияет только на создание вспомогательного свойства и не влияет на код, генерируемый геттером или сеттером.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_делегирование">Делегирование</h3>
<div class="sect3">
<h4 id="_делегирование_класса">Делегирование класса</h4>
<div class="paragraph">
<p><a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Шаблон делегирования</a>
является хорошей альтернативой наследованию, и Kotlin поддерживает его нативно, освобождая вас от необходимости написания шаблонного кода.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main(args: Array&lt;String&gt;) {
    val b = BaseImpl(10)
    Derived(b).print() // prints 10
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ключевое слово <code>by</code> в оглавлении <code>Derived</code>, находящееся после типа делегируемого класса, говорит о том, что объект <code>b</code> типа <code>Base</code> будет храниться внутри экземпляра <code>Derived</code>, и компилятор сгенерирует у <code>Derived</code> соответствующие методы из <code>Base</code>, которые при вызове будут переданы объекту <code>b</code></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_перечисляемые_типы">Перечисляемые типы</h3>
<div class="paragraph">
<p>Наиболее базовый пример использования enum — это реализация типобезопасных перечислений</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">enum class Direction {
    NORTH, SOUTH, WEST, EAST
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Каждая enum-константа является объектом. При объявлении константы разделяются запятыми.</p>
</div>
<div class="sect3">
<h4 id="_инициализация">Инициализация</h4>
<div class="paragraph">
<p>Так как константы являются экземплярами enum-класса, они могут быть инициализированы</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">enum class Color(val rgb: Int) {
        RED(0xFF0000),
        GREEN(0x00FF00),
        BLUE(0x0000FF)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_анонимные_классы">Анонимные классы</h4>
<div class="paragraph">
<p>Enum-константы также могут объявлять свои собственные анонимные классы</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    };

    abstract fun signal(): ProtocolState
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>как с их собственными методами, так и с перегруженными методами базового класса. Следует заметить, что при объявлении
в enum-классе каких-либо членов, необходимо отделять их от списка констант точкой с запятой, так же как и в Java.</p>
</div>
</div>
<div class="sect3">
<h4 id="_работа_с_enum_константами">Работа с enum-константами</h4>
<div class="paragraph">
<p>Так же как и в Java, enum-классы в Kotlin имеют стандартные методы для вывода списка объявленных констант и для получения enum-константы по её имени.
Ниже приведены сигнатуры этих методов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">EnumClass.valueOf(value: String): EnumClass
EnumClass.values(): Array&lt;EnumClass&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>valueOf()</code> выбрасывает исключение <code>IllegalArgumentException</code>, если указанное имя не соответствует ни одной константе, объявленной в классе.</p>
</div>
<div class="paragraph">
<p>Каждая enum-константа имеет поля, в которых содержатся её имя и порядковый номер в enum-классе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val name: String
val ordinal: Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также enum-константы реализуют интерфейс <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html">Comparable</a>. Порядок сортировки соответствует порядку объявления.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_интерфейсы">Интерфейсы</h3>
<div class="paragraph">
<p>Интерфейсы в &lt;b&gt;Kotlin&lt;/b&gt; очень похожи на интерфейсы в &lt;b&gt;Java 8&lt;/b&gt;. Они могут содержать абстрактные методы, методы с реализацией. Главное отличие интерфейсов от абстрактных классов заключается в невозможности хранения переменных экземпляров. Они могут иметь свойства, но те должны быть либо абстрактными, либо предоставлять реализацию методов доступа.</p>
</div>
<div class="paragraph">
<p>Интерфейс определяется ключевым словом <strong>interface</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface MyInterface {
    fun bar()
    fun foo() {
      // необязательное тело
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_реализация_интерфейсов">Реализация интерфейсов</h4>
<div class="paragraph">
<p>Класс или объект могут реализовать любое количество интерфейсов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Child : MyInterface {
    override fun bar() {
        // тело
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_свойства_в_интерфейсах">Свойства в интерфейсах</h4>
<div class="paragraph">
<p>Вы можете объявлять свойства в интерфейсах. Свойство, объявленное в интерфейсе, может быть либо абстрактным, либо иметь свою реализацию методов доступа. Свойства в интерфейсах не могут иметь <em>backing fields</em>, соответственно, методы доступа к таким свойствам не могут обращаться к <em>backing fields</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface MyInterface {
    val prop: Int // абстрактное свойство

    val propertyWithImplementation: String
        get() = "foo"

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_устранение_противоречий_при_переопределении">Устранение противоречий при переопределении</h4>
<div class="paragraph">
<p>Когда мы объявлем большое количество типов в списке нашего супертипа, может так выйти, что мы допустим более одной реализации одного и того же метода. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }

    override fun bar() {
        super&lt;B&gt;.bar()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Оба интерфейса <em>A</em> и <em>B</em> объявляют функции <em>foo()</em> и <em>bar()</em>. Оба реализуют <em>foo()</em>, но только <em>B</em> содержит реализацию <em>bar()</em>
(<strong>bar()</strong> не отмечен как абстрактный метод в интерфейсе <em>A</em>, потому что в интерфейсах это подразумевается по умолчанию, если у функции нет тела). Теперь, если мы унаследуем какой-нибудь класс <em>C</em> от <em>A</em>, нам, очевидно, придётся переопределять <em>bar()</em>, обеспечивать его реализацию.</p>
</div>
<div class="paragraph">
<p>Однако если мы унаследуем <em>D</em> от <em>A</em> и <em>B</em>, нам надо будет переопределять все методы, которые мы унаследовали от этих интерфейсов. Это правило касается как тех методов, у которых имеется только одна реализация (<strong>bar()</strong>), так и тех, у которых есть несколько реализаций (<strong>foo()</strong>).</p>
</div>
<div class="paragraph">
<p>——————————————————————————–
&lt;!--Nested Classes-&#8594;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_вложенные_классы">Вложенные классы</h3>
<div class="paragraph">
<p>Классы могут быть вложены в другие классы</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Outer {
    private val bar: Int = 1
    class Nested {
        fun foo() = 2
    }
}

val demo = Outer.Nested().foo() // == 2</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_внутренние_классы">Внутренние классы</h4>
<div class="paragraph">
<p>Класс может быть отмечен как внутренний с помощью слова <code>inner</code>, тем самым он будет иметь доступ к членам внешнего класса.
Внутренние классы содержат ссылку на объект внешнего класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo() // == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Подробнее об использовании <code>this</code> во внутренних классах: <a href="this-expressions.html">Qualified <code>this</code> expressions</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_анонимные_внутренние_классы">Анонимные внутренние классы</h4>
<div class="paragraph">
<p>Анонимные внутренние экземпляры классов создаются с помощью <a href="object-declarations.html#object-expressions">object expression</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">window.addMouseListener(object: MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }

    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если объект является экземпляром функционального Java-интерфейса (т.е. Java-интерфейса с единственным абстрактным методом),
вы можете создать его с помощью лямбда-выражения с префиксом — типом интерфейса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val listener = ActionListener { println("clicked") }</code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_анонимные_объекты_и_объявление_объектов">Анонимные объекты и объявление объектов</h3>
<div class="paragraph">
<p>Иногда нам необходимо получить экземпляр некоторого класса с незначительной модификацией, желательно без написания нового подкласса. &lt;b&gt;Java&lt;/b&gt; справляется с этим с помощью <em>вложенных анонимных классов</em>.
&lt;b&gt;Kotlin&lt;/b&gt; несколько улучшает данный подход.</p>
</div>
<div class="paragraph">
<p>&lt;a name="object-expressions"&gt;&lt;/a&gt;</p>
</div>
<div class="sect3">
<h4 id="_анонимные_объекты_ориг_object_expressions">Анонимные объекты (ориг.:_Object expressions_)</h4>
<div class="paragraph">
<p>Для того, чтобы создать объект анонимного класса, который наследуется от какого-то типа (типов), используется конструкция:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }

    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у супертипа есть конструктор, то в него должны быть переданы соответсвующие параметры.
Множество супертипов может быть указано после двоеточия в виде списка, заполненного через запятую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class A(x: Int) {
    public open val y: Int = x
}

interface B {...}

val ab: A = object : A(1), B {
    override val y = 15
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если всё-таки нам нужен <em>просто объект</em> без всяких там родительских классов, то можем указать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val adHoc = object {
    var x: Int = 0
    var y: Int = 0
}
print(adHoc.x + adHoc.y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Код внутри объявленного объекта может обращаться к переменным за скобками так же, как вложенные анонимные классы в &lt;b&gt;Java&lt;/b&gt;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun countClicks(window: JComponent) {
    var clickCount = 0
    var enterCount = 0

    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++
        }

        override fun mouseEntered(e: MouseEvent) {
            enterCount++
        }
    })
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;a name="object-declarations"&gt;&lt;/a&gt;</p>
</div>
</div>
<div class="sect3">
<h4 id="_объявления_объектов_ориг_object_declarations">Объявления объектов (ориг.:_Object declarations_)</h4>
<div class="paragraph">
<p>[Синглтон](<a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)</a>) - очень полезный паттерн программирования, и &lt;b&gt;Kotlin&lt;/b&gt; (переняв у &lt;b&gt;Scala&lt;/b&gt;) позволяет объявлять его довольно простым способом :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) {
        // ...
    }

    val allDataProviders: Collection&lt;DataProvider&gt;
        get() = // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это называется <em>объявлением объекта</em> и всегда имеет приставку в виде ключевого слова <strong>object</strong>.
Аналогично объявлению переменной, объявление объекта не является выражением и не может быть использовано в правой части оператора присваивания.</p>
</div>
<div class="paragraph">
<p>Для непосредственной ссылки на объект используется его имя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">DataProviderManager.registerDataProvider(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Подобные объекты могут иметь супертипы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">object DefaultListener : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }

    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ПРИМЕЧАНИЕ</strong>: объявление объекта не может иметь локальный характер (т.е. быть вложенным непосредственно в функцию), но может быть вложено в объявление другого объекта или какого-либо невложенного класса.</p>
</div>
<div class="paragraph">
<p>&lt;a name="companion-objects"&gt;&lt;/a&gt;</p>
</div>
<div class="sect5">
<h6 id="_вспомогательные_объекты">Вспомогательные объекты</h6>
<div class="paragraph">
<p>Объявление объекта внутри класса может быть отмечено ключевым словом <strong>companion</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для вызова членов такого <code>companion</code> объекта используется имя класса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val instance = MyClass.create()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Не обязательно указывать имя вспомогательного объекта. В таком случае он будет назван <code>Companion</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class MyClass {
    companion object {
    }
}

val x = MyClass.Companion</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такие члены вспомогательных объектов выглядят, как статические члены в других языках программирования. На самом же деле, они являются членами реальных объектов и могут реализовывать, к примеру, интерфейсы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface Factory&lt;T&gt; {
    fun create(): T
}

class MyClass {
    companion object : Factory&lt;MyClass&gt; {
        override fun create(): MyClass = MyClass()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако в &lt;b&gt;JVM&lt;/b&gt; вы можете статически генерировать методы вспомогательных объектов и полей, используя аннотацию <code>@JvmStatic@</code>.
См. <a href="http://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-fields">Совместимость с Java</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_семантическое_различие_между_анонимным_объектом_и_декларируемым_объектом">Семантическое различие между анонимным объектом и декларируемым объектом.</h6>
<div class="paragraph">
<p>Существует только одно смысловое различие между этими двумя понятиями:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>анонимный объект инициализируется <strong>сразу после того</strong>, как был использован</p>
</li>
<li>
<p>декларированный объект инициализируется <strong>лениво</strong>, в момент первого к нему доступа</p>
</li>
<li>
<p>вспомогательный объект инициализируется в момент, когда класс, к которому он относится, загружен и семантически совпадает со статическим инициализатором &lt;b&gt;Java&lt;/b&gt;
'''</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_свойства_и_поля">Свойства и поля</h3>
<div class="sect3">
<h4 id="_объявление_свойств">Объявление свойств</h4>
<div class="paragraph">
<p>Классы в &lt;b&gt;Kotlin&lt;/b&gt; могут иметь свойства: изменяемые (<em>mutable</em>) и неизменяемые (<em>read-only</em>) — <strong>var</strong> и <strong>val</strong> соответственно.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">public class Address {
    public var name: String = ...
    public var street: String = ...
    public var city: String = ...
    public var state: String? = ...
    public var zip: String = ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для того, чтобы воспользоваться свойством, мы просто обращаемся к его имени (как в &lt;b&gt;Java&lt;/b&gt;):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun copyAddress(address: Address): Address {
    val result = Address() // нет никакого слова `new`
    result.name = address.name // вызов методов доступа
    result.street = address.street
    // ...
    return result
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_геттеры_и_сеттеры">Геттеры и сеттеры</h4>
<div class="paragraph">
<p>Полный синтаксис объявления свойства выглядит так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;]
    [&lt;getter&gt;]
    [&lt;setter&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Инициализатор <em>property_initializer</em>, геттер и сеттер можно не указывать. Также необязательно указывать тип свойства, если он может быть выведен из контекста или наследован от базового класса.</p>
</div>
<div class="paragraph">
<p>Примеры:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var allByDefault: Int? // ошибка: необходима явная инициализация, предусмотрены стандартные геттер и сеттер
var initialized = 1 // имеет тип Int, стандартный геттер и сеттер</code></pre>
</div>
</div>
<div class="paragraph">
<p>Синтаксис объявления констант имеет два отличия от синтаксиса объявления изменяемых переменных: во-первых, объявление начинается с ключевого слова <code>val</code> вместо <code>var</code>, а во-вторых, объявление сеттера запрещено:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val simple: Int? // имеет тип Int, стандартный геттер, должен быть инициализирован в конструкторе
val inferredType = 1 // имеет тип Int и стандартный геттер</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы можем самостоятельно описать методы доступа, как и обычные функции, прямо при объявлении свойств. Например, пользовательский геттер:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val isEmpty: Boolean
    get() = this.size == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пользовательский сеттер выглядит примерно так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // парсит строку и устанавливает значения для других свойств
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>По договорённости, имя параметра сеттера - <code>value</code>, но вы можете использовать любое другое.</p>
</div>
<div class="paragraph">
<p>Если вам нужно изменить область видимости метода доступа или пометить его аннотацией, при этом не внося изменения в реализацию по умолчанию, вы можете объявить метод доступа без объявления его тела:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var setterVisibility: String = "abc"
    private set // сеттер имеет private доступ и стандартную реализацию

var setterWithAnnotation: Any? = null
    @Inject set // аннотирование сеттера с помощью Inject</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;a name="backing-fields"&gt;&lt;/a&gt;</p>
</div>
<div class="sect5">
<h6 id="_backing_fields">Backing Fields</h6>
<div class="paragraph">
<p>Классы в &lt;b&gt;Kotlin&lt;/b&gt; не могут иметь полей. Т.е. переменные, которые вы объявляете внутри класса только выглядят и ведут себя как поля из Java, хотя на самом деле являются <em>свойствами</em>, т.к. для них неявно реализуются методы get и set. А сама переменная, в которой находится значение свойства, называется <strong>backing field</strong>. Однако, иногда, при использовании пользовательских методов доступа, необходимо иметь доступ к <em>backing field</em>. Для этих целей &lt;b&gt;Kotlin&lt;/b&gt; предоставляет автоматическое <em>backing field</em>, к которому можно обратиться с помощью идентификатора <code>field</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var counter = 0
    set(value) {
        if (value &gt;= 0) field = value // значение при инициализации записывается прямиком в backing field
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Идентификатор <code>field</code> может быть использован только в методах доступа к свойству.</p>
</div>
<div class="paragraph">
<p><em>Backing field</em> будет сгенерировано для свойства, если оно использует стандартную реализацию как минимум одного из методов доступа. Или в случае, когда пользовательский метод доступа ссылается на него через идентификатор <code>field</code>.</p>
</div>
<div class="paragraph">
<p>Например, в нижестоящем примере не будет никакого <em>backing field</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val isEmpty: Boolean
    get() = this.size == 0</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_backing_properties"><em>Backing Properties</em></h6>
<div class="paragraph">
<p>Если вы хотите предпринять что-то такое, что выходит за рамки вышеуказанной схемы "неявного <em>backing field</em>", вы всегда можете использовать <em>backing property</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">private var _table: Map&lt;String, Int&gt;? = null
public val table: Map&lt;String, Int&gt;
    get() {
        if (_table == null) {
            _table = HashMap() // параметры типа вычисляются автоматически (ориг.: "Type parameters are inferred")
        }
        return _table ?: throw AssertionError("Set to null by another thread")
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой подход ничем не отличается от подхода в Java, так как доступ к приватным свойствам со стандартными геттерами и сеттерами оптимизируется таким образом, что вызов функции не происходит.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_константы_времени_компиляции">Константы времени компиляции</h4>
<div class="paragraph">
<p>Свойства, значение которых известно во время компиляции, могут быть помечены как <em>константы времени компиляции</em>. Для этого используется модификатор <code>const</code>. Такие свойства должны соответствовать следующим требованиям:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Находиться на самом высоком уровне или быть членом объекта <code>object</code></p>
</li>
<li>
<p>Быть проинициализированными значением типа <code>String</code> или значением примитивного типа</p>
</li>
<li>
<p>Не иметь переопределённого геттера</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Такие свойства могут быть использованы в аннотациях:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"

@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_свойства_с_поздней_инициализацией">Свойства с поздней инициализацией</h4>
<div class="paragraph">
<p>Обычно, свойства, объявленные non-null типом, должны быть проинициализированы в конструкторе. Однако, довольно часто это неосуществимо. К примеру, свойства могут быть инициализированы через внедрение зависимостей, в установочном методе (ориг.: <em>"setup method"</em>) юнит-теста или в методе <code>onCreate</code> в Android. В таком случае вы не можете обеспечить non-null инициализацию в конструкторе, но всё равно хотите избежать проверок на null при обращении внутри тела класса к такому свойству.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы справиться с такой задачей, вы можете пометить свойство модификатором <code>lateinit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">public class MyTest {
    lateinit var subject: TestSubject

    @SetUp fun setup() {
        subject = TestSubject()
    }

    @Test fun test() {
        subject.method()  // объект инициализирован, проверять на null не нужно
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой модификатор может быть использован только с <code>var</code> свойствами, объявленными внутри тела класса (не в главном конструкторе, и только тогда, когда свойство не имеет пользовательских геттеров и сеттеров) и, начиная с Kotlin 1.2, со свойствами, расположенными на верхнем уровне, и локальными переменными. Тип такого свойства должен быть non-null и не должен быть примитивным.</p>
</div>
<div class="paragraph">
<p>Доступ к <code>lateinit</code> свойству до того, как оно проинициализировано, выбрасывает специальное исключение, которое чётко обозначает, что свойство не было определено.</p>
</div>
<div class="sect5">
<h6 id="_проверка_инициализации_lateinit_var_начиная_с_версии_1_2">Проверка инициализации lateinit var (начиная с версии 1.2)</h6>
<div class="paragraph">
<p>Чтобы проверить, была ли проинициализировано <code>lateinit var</code> свойство, используйте <code>.isInitialized</code> метод <a href="reflection.html#property-references">ссылки на это свойство</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">if (foo::bar.isInitialized) {
    println(foo.bar)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта проверка возможна только для лексически доступных свойств, то есть объявленных в том же типе, или в одном из внешних типов, или расположенных на верхнем того же файла.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_переопределение_свойств">Переопределение свойств</h4>
<div class="paragraph">
<p>См. <a href="http://kotlinlang.ru/docs/reference/classes.html#overriding-properties">Переопределение членов класса</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_делегированные_свойства_2">Делегированные свойства</h4>
<div class="paragraph">
<p>Самый распространённый тип свойств просто считывает (или записывает) данные из <em>backing field</em>.
Тем не менее, с пользовательскими геттерами и сеттерами мы можем реализовать совершенно любое поведение свойства.
В реальности, существуют общепринятые шаблоны того, как могут работать свойства. Несколько примеров:
* Вычисление значения свойства при первом доступе к нему (ленивые свойства)
* Чтение из ассоциативного списка с помощью заданного ключа
* Доступ к базе данных
* Оповещение listener&#8217;а в момент доступа
и т.п.</p>
</div>
<div class="paragraph">
<p>Такие распространённые поведения свойств могут быть реализованы в виде библиотек с помощью <a href="https://kotlinlang.ru/docs/reference/delegated-properties.html"><em>делегированных свойств</em></a>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_изолированные_классы">Изолированные классы</h3>
<div class="paragraph">
<p>Изолированные классы используются для отражения ограниченных иерархий классов, когда значение может иметь тип только из ограниченного набора, и никакой другой. Они являются, по сути, расширением enum-классов: набор значений enum типа также ограничен, но каждая enum-константа существует только в единственном экземпляре, в то время как наследник изолированного класса может иметь множество экземпляров, которые могут нести в себе какое-то состояние.</p>
</div>
<div class="paragraph">
<p>Чтобы описать изолированный класс, укажите модификатор <code>sealed</code> перед именем класса. Изолированный класс может иметь наследников, но все они должны быть объявлены в том же файле, что и сам изолированный класс. (До версии Kotlin 1.1 правила были ещё более строгими: классы должны были быть вложены в объявлении изолированного класса).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Double = when (expr) {
    is Const -&gt; expr.number
    is Sum -&gt; eval(expr.e1) + eval(expr.e2)
    NotANumber -&gt; Double.NaN
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Пример выше использует одну новую возможность Kotlin 1.1: расширение классов, включая изолированные, классами данных)
Обратите внимание, что классы, которые расширяют наследников изолированного класса (непрямые наследники) могут быть помещены где угодно, не обязательно в том же файле.</p>
</div>
<div class="paragraph">
<p>Ключевое преимущество от использования изолированных классов проявляется тогда, когда вы используете их в <a href="control-flow.html#when-expression">выражении when</a>. Если возможно проверить что выражение покрывает все случаи, то вам не нужно добавлять <code>else</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun eval(expr: Expr): Double = when(expr) {
    is Expr.Const -&gt; expr.number
    is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)
    Expr.NotANumber -&gt; Double.NaN
    // оператор `else` не требуется, потому что мы покрыли все возможные случаи
}</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_ключевое_слово_this">Ключевое слово this</h3>
<div class="paragraph">
<p>Чтобы сослаться на объект, с которым мы работаем, используется ключевое слово <em>this</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Внутри <a href="classes.html#inheritance">класса</a> ключевое слово <em>this</em> ссылается на объект этого класса</p>
</li>
<li>
<p>В <a href="extensions.html">функциях-расширениях</a> или в <a href="lambdas.html#function-literals-with-receiver">литерале функции с принимающим объектом</a> <em>this</em> обозначает
<em>принимающий объект</em>, который передаётся слева от точки.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если ключевое слово <em>this</em> не имеет определителей, то оно ссылается на <em>область самого глубокого замыкания</em>.
Чтобы сослаться на <em>this</em> в одной из внешних областей, используются <em>метки-определители</em>:</p>
</div>
<div class="sect3">
<h4 id="_this_с_определителем"><em>this</em> с определителем</h4>
<div class="paragraph">
<p>Чтобы получить доступ к <em>this</em> из внешней области (<a href="classes.html">класса</a>, <a href="extensions.html">функции-расширения</a>,
или именованных <a href="lambdas.html#function-literals-with-receiver">литералов функций с принимающим объектом</a>) мы пишем <code>this@label</code>, где <code>@label</code> - это <a href="returns.html">метка</a> области, из которой нужно получить <em>this</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class A { // неявная метка @A
    inner class B { // неявная метка @B
        fun Int.foo() { // неявная метка @foo
            val a = this@A // this из A
            val b = this@B // this из B

            val c = this // принимающий объект функции foo(), типа Int
            val c1 = this@foo // принимающий объект функции foo(), типа Int

            val funLit = lambda@ fun String.() {
                val d = this // принимающий объект литерала funLit
            }

            val funLit2 = { s: String -&gt;
                // принимающий объект функции foo(), т.к. замыкание лямбды не имеет принимающего объекта
                val d1 = this
            }
        }
    }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_модификаторы_доступа">Модификаторы доступа</h3>
<div class="paragraph">
<p>Классы, объекты, интерфейсы, конструкторы, функции, свойства и их сеттеры могут иметь <em>модификаторы доступа</em> (у геттеров всегда такая же видимость, как у свойств, к которым они относятся). В &lt;b&gt;Kotlin&lt;/b&gt; предусмотрено четыре модификатора доступа: <code>private</code>, <code>protected</code>, <code>internal</code> и <code>public</code>. Если явно не используется никакого модификатора доступа, то по умолчанию применяется <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Ниже вы найдёте описание всех возможных способов задавать область видимости.</p>
</div>
<div class="sect3">
<h4 id="_пакеты">Пакеты</h4>
<div class="paragraph">
<p>Функции, свойства, классы, объекты и интерфейсы могут быть объявлены на самом "высоком уровне" прямо внутри пакета:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// имя файла: example.kt
package foo

fun baz() {}
class Bar {}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если вы не укажете никакого модификатора доступа, будет использован <code>public</code>. Это значит, что весь код данного объявления будет виден из космоса;</p>
</li>
<li>
<p>Если вы пометите объявление словом <code>private</code>, оно будет иметь видимость только внутри файла, где было объявлено;</p>
</li>
<li>
<p>Если вы используете <code>internal</code>, видимость будет распространяться на весь <a href="visibility-modifiers.html#modules">модуль</a>;</p>
</li>
<li>
<p><code>protected</code> запрещено использовать в объявлениях "высокого уровня".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Примеры:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// file name: example.kt
package foo

private fun foo() {} // имеет видимость внутри example.kt

public var bar: Int = 5 // свойство видно со дна Марианской впадины
    private set         // сеттер видно только внутри example.kt

internal val baz = 6    // имеет видимость внутри модуля</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_классы_и_интерфейсы">Классы и интерфейсы</h4>
<div class="paragraph">
<p>Для членов, объявленых в классе:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>private</code> означает видимость только внутри этого класса (включая его членов);</p>
</li>
<li>
<p><code>protected</code> — то же самое, что и <code>private</code> + видимость в субклассах;</p>
</li>
<li>
<p><code>internal</code> — любой клиент <em>внутри модуля</em>, который видит объявленный класс, видит и его <code>internal</code> члены;</p>
</li>
<li>
<p><code>public</code> — любой клиент, который видит объявленный класс, видит его <code>public</code> члены.</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>Примечание для Java программистов:</em> в &lt;b&gt;Kotlin&lt;/b&gt; внешний класс не видит <code>private</code> члены своих вложенных классов.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Если вы переопределите <code>protected</code> член и явно не укажете его видимость, переопределённый элемент также будет иметь модификатор доступа <code>protected</code>.</p>
</div>
<div class="paragraph">
<p>Примеры:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">open class Outer {
    private val a = 1
    protected open val b = 2
    internal val c = 3
    val d = 4  // public по умолчанию

    protected class Nested {
        public val e: Int = 5
    }
}

class Subclass : Outer() {
    // a не видно
    // b, c и d видно
    // класс Nested и e видно

    override val b = 5   // 'b' - protected
}

class Unrelated(o: Outer) {
    // o.a, o.b не видно
    // o.c и o.d видно (тот же модуль)
    // Outer.Nested не видно, и Nested::e также не видно
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;a name="constructors"&gt;&lt;/a&gt;</p>
</div>
<div class="sect5">
<h6 id="_конструкторы_2">Конструкторы</h6>
<div class="paragraph">
<p>Для указания видимости главного конструктора класса используется следующий синтаксис (кстати, надо добавить ключевое слово <em>constructor</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class C private constructor(a: Int) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом примере конструктор является <code>private</code>. По умолчанию все конструкторы имеют модификатор доступа <code>public</code>, то есть видны везде, где виден сам класс (а вот конструктор <code>internal</code> класса видно только в том же модуле).</p>
</div>
</div>
<div class="sect5">
<h6 id="_локальные_объявления">Локальные объявления</h6>
<div class="paragraph">
<p>Локальные переменные, функции и классы не могут иметь модификаторов доступа. &lt;!--rcd27: неожиданно&#8230;&#8203;-&#8594;</p>
</div>
<div class="paragraph">
<p>&lt;a name="modules"&gt;&lt;/a&gt;</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_модули">Модули</h4>
<div class="paragraph">
<p>Модификатор доступа <code>internal</code> означает, что этот член видно в рамках его модуля. Модуль - это набор скомпилированных вместе &lt;b&gt;Kotlin&lt;/b&gt; файлов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>модуль в IntelliJ IDEA;</p>
</li>
<li>
<p>Maven или Gradle проект;</p>
</li>
<li>
<p>набор скомпилированных вместе файлов с одним способом вызова <code>&lt;kotlinc&gt;</code> задачи в Ant.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_стандартная_библиотека">3. Стандартная библиотека</h3>
<div class="ulist">
<ul>
<li>
<p>Основные функции стандартной библиотеки</p>
</li>
<li>
<p>Обзор пакетов</p>
<div class="ulist">
<ul>
<li>
<p>Collections</p>
</li>
<li>
<p>Math</p>
</li>
<li>
<p>Sequence</p>
</li>
<li>
<p>Concurrent</p>
</li>
<li>
<p>IO</p>
</li>
<li>
<p>Streams (Java 8 Streams)</p>
</li>
<li>
<p>text</p>
</li>
</ul>
</div>
</li>
<li>
<p>Написание собственных расширений: полезные советы и чего не стоит делать</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_4_функциональное_программирование">4. Функциональное программирование</h3>
<div class="ulist">
<ul>
<li>
<p>Функции высшего порядка (ФВП)</p>
</li>
<li>
<p>Функция как тип данных</p>
</li>
<li>
<p>Лямбда выражения</p>
</li>
<li>
<p><em>inline</em> функции</p>
</li>
<li>
<p><em>return</em> в ФВП</p>
</li>
<li>
<p>Анонимные функции</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_5_generic">5. Generic</h3>
<div class="ulist">
<ul>
<li>
<p>Типизация функций и property</p>
</li>
<li>
<p>Типизация классов</p>
</li>
<li>
<p>Ограничения типа</p>
</li>
<li>
<p>Вариантность</p>
<div class="ulist">
<ul>
<li>
<p>Что такое и зачем нужна</p>
</li>
<li>
<p>Классы, типы, подтипы</p>
</li>
<li>
<p>Ковариантность</p>
</li>
<li>
<p>Контравариантность</p>
</li>
<li>
<p>Проекция *</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_6_kotlin_dsl_multiplatform">6. Kotlin DSL + Multiplatform</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin DSL</p>
<div class="ulist">
<ul>
<li>
<p>Что такое DSL?</p>
</li>
<li>
<p>Где применяется</p>
</li>
<li>
<p>Создание своего собственного DSL</p>
</li>
</ul>
</div>
</li>
<li>
<p>Multiplatform</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_7_корутины">7. Корутины</h3>
<div class="ulist">
<ul>
<li>
<p>Что значит <em>suspendable</em>?</p>
</li>
<li>
<p>Отличия blocking от suspendable</p>
</li>
<li>
<p>Поддержка корутин в Kotlin</p>
</li>
<li>
<p>kotlinx.coroutines</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_8_обратная_совместимость_с_java">8. Обратная совместимость с Java</h3>
<div class="ulist">
<ul>
<li>
<p>Kotlin &lt; - &gt; JVM interoperability</p>
</li>
<li>
<p>Написание Kotlin кода для удобного использования из Java</p>
</li>
<li>
<p>Написание Java кода для удобного использования из Kotlin</p>
</li>
<li>
<p>Отличия Kotlin от Java</p>
</li>
<li>
<p>Kotlin Java Bytecode IDEA Plugin</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_puzzler">Puzzler</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">import java.lang.reflect.Proxy

interface Foo {
    fun bar(): String
}

class MyException : Exception()

val foo = Proxy.newProxyInstance(
    Foo::class.java.classLoader,
    arrayOf(Foo::class.java)
) { _, _, _ -&gt; throw MyException() } as Foo

fun main() {
    try {
        println(foo.bar())
    } catch (t: MyException) {
        println("Oops")
    }
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_9_экосистема_kotlin">9. Экосистема Kotlin</h3>
<div class="ulist">
<ul>
<li>
<p>Интеграция Kotlin в популярных фреймворках</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/gradle/kotlin-dsl">Gradle Kotlin DSL</a></p>
</li>
<li>
<p><a href="https://developer.android.com/kotlin/">Android SDK: Kotlin Support</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.android.com/kotlin/ktx">Android KTX</a></p>
</li>
<li>
<p><a href="https://github.com/Kotlin/anko">Anko</a></p>
</li>
<li>
<p><a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">Kotlin Android Extensions</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Spring Boot with Kotlin</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Популярные библиотеки</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://insert-koin.io/">Koin</a> - DI</p>
</li>
<li>
<p><a href="https://github.com/cbeust/klaxon">Klaxon</a> - JSON parsing</p>
</li>
<li>
<p>Server</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://ktor.io/">Ktor</a></p>
</li>
<li>
<p><a href="http://sparkjava.com/">Spark</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Android</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">PermissionsDispatcher</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://github.com/edvin/tornadofx">TornadoFX</a></p>
</li>
<li>
<p>Testing</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://spekframework.org/">Spek</a></p>
</li>
<li>
<p><a href="https://mockk.io/">MockK</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://kotlin.link/">Kotlin Links</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Tooling</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://arturbosch.github.io/detekt/">detekt</a></p>
</li>
<li>
<p><a href="https://github.com/shyiko/ktlint">Ktlint</a></p>
</li>
<li>
<p><a href="https://docs.sonarqube.org/display/PLUG/SonarKotlin">SonarQube Kotlin Plugin</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_команда_курса">Команда курса</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_лекторы">Лекторы</h3>
<div class="ulist">
<ul>
<li>
<p>Кирилл Розов <a href="mailto:krl.rozov@gmail.com">krl.rozov@gmail.com</a></p>
</li>
<li>
<p>Руслан Ибрагимов <a href="mailto:ruslan@ibragimov.by">ruslan@ibragimov.by</a></p>
</li>
<li>
<p>Сергей Крюков <a href="mailto:siarhei.krukau@gmail.com">siarhei.krukau@gmail.com</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_менторы">Менторы</h3>

</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-12-06 10:31:33 UTC
</div>
</div>
</body>
</html>